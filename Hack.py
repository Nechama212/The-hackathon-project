# -*- coding: utf-8 -*-
"""hackathon.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/122lY1w2Vr4mwaTrgjk48RBtjgl0TCZhD
"""
from geopy.geocoders import Nominatim
import math
import sys
import itertools 
import pandas as pd  
import tkinter
  
# Create the default window






data_base = pd.read_excel("shopes.xlsx")
data_base = pd.read_excel("shopes.xlsx")  

# after you get your catagory from user send to :
user_catagory = "אוכל"
table_by_catagory = data_base[data_base['category'] == user_catagory]
# for list of address:
address_by_catagory = table_by_catagory['eng_address']
# for list of shop_names:
shop_name_by_catagory = table_by_catagory['name']
shop_address_by_catagory = table_by_catagory['eng_address']





  # send to algorithm



def getLocByAddress(address):
  loc = Nominatim(user_agent="GetLoc")
  location = loc.geocode(address)
  he_address = location.address
  # print("he: " + he_address )
  pointX = location.latitude
  pointY = location.longitude
  return pointX, pointY


def dist(x,y):
    return math.hypot(y[0]-x[0],y[1]-x[1])

def combination_length(start_point, combination):
    lenght = 0
    previous = start_point  
    for elem in combination:
      lenght += dist(previous, elem)

    return lenght
    
def get_shortest_path(start_point, list_of_points):
    min = sys.maxsize
    combination_min = None
    list_of_combinations = list(itertools.permutations(list_of_points))
    for combination in list_of_combinations:
        length = combination_length(start_point, combination)
        if length < min:
            min = length
            combination_min = combination

    return combination_min



def shortPath(start_address, list_of_address, list_of_names): # get it from sql dataBase
    list_of_points = [] # empty list
    #list_name_sort = [] # empty list
    dict_of_point_to_address = {}
    dict_of_point_to_name = {}
    for address in list_of_address:
      p = getLocByAddress(address)
      list_of_points.append(p)
      #list_name_sort.append(k)
      dict_of_point_to_address[p] = address
      dict_of_point_to_name[p] = findInSecondList(address, list_of_address, list_of_names)
    # print(list_of_points)
    start_point = getLocByAddress(start_address)
    list_of_path = get_shortest_path(start_point, list_of_points)
    # print("res: {}".format(list_of_path))
    for idx in range(0, len(list_of_path)):
      print("{} : {} - {}".format(idx + 1 , dict_of_point_to_name[list_of_path[idx]] , dict_of_point_to_address[list_of_path[idx]]))


def findInSecondList (value, list1, list2):
    for (node1, node2) in zip(list1, list2):
        if node1 == value:
          return node2



shortPath("Malkei Israel 45 Jerusalem Israel", shop_address_by_catagory, shop_name_by_catagory)

address = ["Malkei Israel 26, Jerusalem","Amos 10, Jerusalem","Malachi 5, Jerusalem","Malkei Israel 43, Jerusalem"]
name_of_shops = ["`Sam Bagels","Bagir","KIWI","Jerusalem Pizza"]

print("You are in: Malkei Israel 26, Jerusalem\n")
print("Your pass is: \n")
shortPath("Malkei Israel 45 Jerusalem Israel", address, name_of_shops)

